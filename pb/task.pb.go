// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pb/task.proto

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	pb/task.proto

It has these top-level messages:
	OwnerState
	Task
	TaskResp
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type OwnerState struct {
	Owner  string `protobuf:"bytes,1,opt,name=Owner" json:"Owner,omitempty"`
	Group  string `protobuf:"bytes,2,opt,name=Group" json:"Group,omitempty"`
	TaskId int64  `protobuf:"zigzag64,3,opt,name=TaskId" json:"TaskId,omitempty"`
}

func (m *OwnerState) Reset()                    { *m = OwnerState{} }
func (m *OwnerState) String() string            { return proto.CompactTextString(m) }
func (*OwnerState) ProtoMessage()               {}
func (*OwnerState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *OwnerState) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *OwnerState) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *OwnerState) GetTaskId() int64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

type Task struct {
	Group  string `protobuf:"bytes,1,opt,name=Group" json:"Group,omitempty"`
	TaskId int64  `protobuf:"zigzag64,2,opt,name=TaskId" json:"TaskId,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Task) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Task) GetTaskId() int64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

type TaskResp struct {
	Group         string `protobuf:"bytes,1,opt,name=Group" json:"Group,omitempty"`
	TaskId        int64  `protobuf:"zigzag64,2,opt,name=TaskId" json:"TaskId,omitempty"`
	EnableSeconds int64  `protobuf:"zigzag64,3,opt,name=EnableSeconds" json:"EnableSeconds,omitempty"`
}

func (m *TaskResp) Reset()                    { *m = TaskResp{} }
func (m *TaskResp) String() string            { return proto.CompactTextString(m) }
func (*TaskResp) ProtoMessage()               {}
func (*TaskResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TaskResp) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *TaskResp) GetTaskId() int64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *TaskResp) GetEnableSeconds() int64 {
	if m != nil {
		return m.EnableSeconds
	}
	return 0
}

func init() {
	proto.RegisterType((*OwnerState)(nil), "pb.OwnerState")
	proto.RegisterType((*Task)(nil), "pb.Task")
	proto.RegisterType((*TaskResp)(nil), "pb.TaskResp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TaskMaster service

type TaskMasterClient interface {
	// Register 服务端向下推送,终止任务
	Register(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Task, error)
	// Report 客户端请求,续租任务
	Connect(ctx context.Context, opts ...grpc.CallOption) (TaskMaster_ConnectClient, error)
}

type taskMasterClient struct {
	cc *grpc.ClientConn
}

func NewTaskMasterClient(cc *grpc.ClientConn) TaskMasterClient {
	return &taskMasterClient{cc}
}

func (c *taskMasterClient) Register(ctx context.Context, in *Task, opts ...grpc.CallOption) (*Task, error) {
	out := new(Task)
	err := grpc.Invoke(ctx, "/pb.TaskMaster/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskMasterClient) Connect(ctx context.Context, opts ...grpc.CallOption) (TaskMaster_ConnectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_TaskMaster_serviceDesc.Streams[0], c.cc, "/pb.TaskMaster/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &taskMasterConnectClient{stream}
	return x, nil
}

type TaskMaster_ConnectClient interface {
	Send(*OwnerState) error
	Recv() (*TaskResp, error)
	grpc.ClientStream
}

type taskMasterConnectClient struct {
	grpc.ClientStream
}

func (x *taskMasterConnectClient) Send(m *OwnerState) error {
	return x.ClientStream.SendMsg(m)
}

func (x *taskMasterConnectClient) Recv() (*TaskResp, error) {
	m := new(TaskResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for TaskMaster service

type TaskMasterServer interface {
	// Register 服务端向下推送,终止任务
	Register(context.Context, *Task) (*Task, error)
	// Report 客户端请求,续租任务
	Connect(TaskMaster_ConnectServer) error
}

func RegisterTaskMasterServer(s *grpc.Server, srv TaskMasterServer) {
	s.RegisterService(&_TaskMaster_serviceDesc, srv)
}

func _TaskMaster_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskMasterServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.TaskMaster/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskMasterServer).Register(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskMaster_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TaskMasterServer).Connect(&taskMasterConnectServer{stream})
}

type TaskMaster_ConnectServer interface {
	Send(*TaskResp) error
	Recv() (*OwnerState, error)
	grpc.ServerStream
}

type taskMasterConnectServer struct {
	grpc.ServerStream
}

func (x *taskMasterConnectServer) Send(m *TaskResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *taskMasterConnectServer) Recv() (*OwnerState, error) {
	m := new(OwnerState)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _TaskMaster_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.TaskMaster",
	HandlerType: (*TaskMasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _TaskMaster_Register_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _TaskMaster_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb/task.proto",
}

func init() { proto.RegisterFile("pb/task.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 218 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2d, 0x48, 0xd2, 0x2f,
	0x49, 0x2c, 0xce, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x2a, 0x48, 0x52, 0x0a, 0xe0,
	0xe2, 0xf2, 0x2f, 0xcf, 0x4b, 0x2d, 0x0a, 0x2e, 0x49, 0x2c, 0x49, 0x15, 0x12, 0xe1, 0x62, 0x05,
	0xf3, 0x24, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83, 0x20, 0x1c, 0x90, 0xa8, 0x7b, 0x51, 0x7e, 0x69,
	0x81, 0x04, 0x13, 0x44, 0x14, 0xcc, 0x11, 0x12, 0xe3, 0x62, 0x0b, 0x49, 0x2c, 0xce, 0xf6, 0x4c,
	0x91, 0x60, 0x56, 0x60, 0xd4, 0x10, 0x0a, 0x82, 0xf2, 0x94, 0x4c, 0xb8, 0x58, 0x40, 0x2c, 0x84,
	0x2e, 0x46, 0xec, 0xba, 0x98, 0x50, 0x74, 0xc5, 0x71, 0x71, 0x80, 0x58, 0x41, 0xa9, 0xc5, 0x05,
	0xa4, 0xe9, 0x14, 0x52, 0xe1, 0xe2, 0x75, 0xcd, 0x4b, 0x4c, 0xca, 0x49, 0x0d, 0x4e, 0x4d, 0xce,
	0xcf, 0x4b, 0x29, 0x86, 0x3a, 0x07, 0x55, 0xd0, 0x28, 0x96, 0x8b, 0x0b, 0xa4, 0xde, 0x37, 0xb1,
	0xb8, 0x24, 0xb5, 0x48, 0x48, 0x81, 0x8b, 0x23, 0x28, 0x35, 0x3d, 0x13, 0xcc, 0xe6, 0xd0, 0x2b,
	0x48, 0xd2, 0x03, 0xc9, 0x49, 0xc1, 0x59, 0x4a, 0x0c, 0x42, 0xba, 0x5c, 0xec, 0xce, 0xf9, 0x79,
	0x79, 0xa9, 0xc9, 0x25, 0x42, 0x7c, 0x20, 0x61, 0x44, 0x20, 0x49, 0xf1, 0xc0, 0x94, 0x81, 0x1c,
	0xab, 0xc4, 0xa0, 0xc1, 0x68, 0xc0, 0x98, 0xc4, 0x06, 0x0e, 0x51, 0x63, 0x40, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xe9, 0x8f, 0xdc, 0xa4, 0x62, 0x01, 0x00, 0x00,
}
